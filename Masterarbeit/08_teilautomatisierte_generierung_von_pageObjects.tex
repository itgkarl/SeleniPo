
\chapter{Teilautomatisierte Generierung von Page Objects}
\label{sec:teilautomatisierte_generierung_von_pageObjects}

Ein großer Teil des in Kapitel \ref{sec:probleme_des_page_object_pattern} angesprochenen initialen Mehraufwands bei der Verwendung des Page Object Pattern beläuft sich auf die Erstellung der Page Objects.
Wie in Listing \ref{lst:poCreatePage} und \ref{lst:poShowPage} zu sehen ist, handelt es sich bei Page Objects jedoch um wenig komplexe Klassen. In der Praxis zeigt sich, dass ein Großteil der Arbeit darin besteht die verschiedenen Locatoren der Elemente aus dem Quelltext der Seite herauszufinden und in die generische Form eines Page Objects zu überführen.
Diese Arbeit kostet zwar viel Zeit, ist allerdings nicht gerade anspruchsvoll.
Möchte man den initialen Mehraufwand bei der Verwendung des Page Object Pattern entgegenwirken bieten die Page Objects somit einen guten Ansatzpunkt.
Ihre Erstellung ist zeitaufwendig und weitestgehend generisch. Gute Voraussetzungen also um das Erzeugen der Pagae Objects zu Automatisieren.
\section{Übersicht über die Idee}
\label{sec:uebersicht_ueber_idee}


Selenium in Verbindung mit dem Page Object Pattern ist auch ein Teil des Technologiestacks des IT-Dienstleisters der Landeshauptstadt München (it@M) und wird dort zum Testen komplexer Webanwendungen verwendet. Auch bei it@M hat man in Bezug auf die Erstellung der Page Objects die Erfahrungen gemacht, dass es sich um eine generische und zeitaufwendige Arbeit handelt.
In Zusammenarbeit mit it@M wurde daher die Idee entwickelt, das Erstellen von Page Objects mit Hilfe einer Softwarelösung zu unterstützen. 
Anhand des Seitenquelltextes der zu testenden Webanwendung sollen die verschiedenen Elemente des Page Objects identifiziert und zur Generierung der Page Objects verwendet werden.
Zwei Ansätze wurden dabei diskutiert. Eine vollautomatisierte Generierung von Page Objects und eine teilautomatisierte Generierung.
Ein vollautomatischer Ansatz würde beinhalten, dass für einen übergebenen Seitenquelltext ohne weiteres Zutun ein vollständiges Page Object generiert wird. Dieser Ansatz hat jedoch mit zahlreichen Problemen zu kämpfen. Oft wird nur ein Bruchteil der Elemente einer Webseite für die Testfälle benötigt. Selenium kann aber prinzipiell jedes Element, dass im Seitenquelltext bereitgestellt wird, ansprechen. Bei einer vollautomatischen Generierung müssten daher entweder alle Elemente einer Seite übernommen oder eine definierte Auswahl getroffen werden.
Wird eine Auswahl getroffen besteht das Risiko, dass Elemente ausgelassen werden die vom Tester möglicherweise benötigt werden. Werden alle Elemente übernommen, werden die Page Objects schnell überladen und unübersichtlich. Das Überladen der Page Objects geschieht dann auf Kosten der Robustheit. Strukturelle Änderungen in der Website wirken sich auch auf die Locatoren der Elemente in den Page Objects aus. Um die Page Objects stabil zu halten, müssen diese bei Änderungen in der Seitenstruktur berichtigt werden.
Es ist daher nicht sinnvoll Elemente in den Page Objects zu pflegen, die nicht verwendet werden. Unbenutzte Elemente bedeuten entweder zusätzlichen Wartungsaufwand oder veralten unbemerkt.
Ein weiteres Problem des vollautomatischen Ansatzes stellen die Übergänge zwischen den Seiten einer Webanwendung dar. Interaktionen mit der Webanwendung wie beispielsweise das betätigen eines Button führen oft zum aufrufen einer neuen Seite. Im weiteren werden diese Übergänge als Transitions bezeichnet. Diese Transitions werden optimaler weise auch in den Page Objects abgebildet. Das Page Object gibt dazu das entsprechende Page Object der Zielseite als Rückgabe eines Methodenaufrufs zurück, wie es beispielsweise in der Methode createEntry() im Listing \ref{lst:poCreatePage} gezeigt ist. Allein aus dem Seitenquelltext zu ermitteln welche Seite das Ziel einer Transition ist erweist sich jedoch oft als sehr schwierig bis unmöglich.
Um die Komplexität des Projektes auf Grund der genannten Probleme nicht zu groß werden zu lassen wurde sich für einen teilautomatisierte Lösung entschieden.
Ziel ist es also nicht, automatisch ein vollständiges Page Object zu generieren sondern den Entwickler bei der Generierung der Page Objects zu unterstützen. Anhand des Quelltextes sollen dem Entwickler die möglichen Elemente der Seite in einer Vorauswahl bereitgestellt werden. Aus diesen Elementen können dann diejenigen ausgewählt werden, die vom Entwickler im späteren Page Object benötigt werden. Auf diese Weise wird eine Überladung der Page Objects verhindert und gleichzeitig sichergestellt, dass die Elemente vorhanden sind, die benötigt werden.
Ob es sich bei einem Element um eine Transition handelt, also ein Element welches auf eine neue Seite führt, muss auch nicht mehr automatisch anhand des Quelltextes ermittelt werden sonder kann vom Entwickler direkt bei der Auswahl der benötigten Elemente mit angegeben werden.
Die so vom Entwickler ausgewählten Informationen können dann verwendet werden um daraus das fertige Page Object zu generieren.
Im Rahmen des Projektes SeleniPo soll dieser Ansatz in Zusammenarbeit mit it@M in Form einer Denktopanwendung umgesetzt werden. 

\section{Abgrenzung zu bestehenden Ansätzen}
\label{sec:abgrenzung_zu_bestehenden_ansaetzen}
Sowohl für die vollautomatische Generierung von Page Objects als auch für eine teilautomatisierten Generierung gibt es bereits mögliche Lösungsansätze. 
Stocco et al. \cite{stocco_why_2015} beschreiben in einem Paper das von ihnen entwickeltes Framework APOGEN mit deren Hilfe Page Objects vollautomatisch generiert werden können. Die Generierung der Page Objects soll dabei weit über das Anlegen von Elementen hinausgehen und auch die Funktionalitäten der einzelnen Webseiten in Form von Methoden mit einschließen.
Das Framework analysiert dazu die Struktur der Webanwendung mittels eines Crawlers. Die Informationen die über den Crawler zusammengetragen wurden, wie beispielsweise das DOM der einzelnen Webseiten, werden anschließend über eine statische Analyse aufbereitet und für die Generierung der Page Objects verwendet.
Nach eigenen Angaben sollen ca. 75\% des von APOGEN generierten Codes ohne Anpassungen verwendet werden können. Die restlichen 25\% benötigen nur kleine Änderungen.
Bei APOGEN handelt es sich jedoch um ein noch sehr junges Projekt. Das Paper zu diesem Projekt wurde im Mai 2015 veröffentlicht. APOGEN ist daher eher einen Prototyp der zwar die Möglichkeiten aufzeigt die in diesem Bereich gegeben sind jedoch noch nicht für den produktiven Einsatz in einem großen unternehmen geeignet ist.
Nach eigenen Angaben Leidet das Projekt noch unter einigen Einschränkungen. Eine der genannten Einschränkungen ist die Limitierung durch den Crawler.
APOGEN kann nur Webseiten in Page Objects umwandeln, die auch durch den Crawler erreicht wurden.
Für einfache Webanwendungen stellt das kein großes Problem da, für sehr komplexe Anwendungen mit einer ausgeprägten logischen Validierung allerdings schon.
Viele Seiten die hinter logisch validierten Eingaben liegen können vom Crawler nicht erreicht werden und stehen somit für die Generierung nicht zur Verfügung.

Neben der vollautomatischen Generierung existieren noch eine Reihe von Open-Source-Framworks 
die einen teilautomatisierten Ansatz verfolgen, ähnlich wie es das Projekt SelneiPo erreichen will.
Stocco et al. \cite{stocco_why_2015} nennen in ihrem Paper die drei derzeit wichtigsten Vertreter:

\begin{itemize}
\item \textit{OHMAP} \cite{virtuetech_gmbh_ohmap_2015}: Bei OHMAP handelt es sich um eine online Webseite die es dem Benutzer erlaubt HTML-Code in eine Textarea zu Kopieren. Aus dem übergebenen HTML-Code generiert das Tool eine einfache Java-Klasse die für jedes gefundene Input-Feld ein WebElement enthält. Die Variablennamen werden dabei aus den HTML-Attributen gebildet. Als Locator wird ein einfacher XPath-Ausdruck verwendet.
	
\item \textit{SWD Page Recorder} \cite{dmytro_zharii_dzharii/swd-recorder_2015}: Der SWD Page Recorder ermöglicht es dem Benutzer eine beliebige Webanwendung zu starten und das GUI der Anwendung mit einem click\&record-Mechanismus zu inspizieren.
Nach jedem Klick auf das Interface der Anwendung wird ein drop-down-Menü angezeigt in welches manuell ein Name für das ausgewählte Element angegeben werden kann. Als Locator wird ein einfacher XPath-Ausdruck generiert.
Das so erstellte Modell der Anwendung kann in verschiedene Sprachen exportiert werden, wie beispielsweise Java, C\#, Rython, Ruby oder Perl. Beim SWD Page Recorder handelt es sich um eine .NET Anwendung.

\item\textit{ WTF PageObject Utility Chrome Extension} \cite{daniel_wiredrive/wtframework_2015}: WTF unterstützt den Entwickler beim erstellen von Page Objects indem Locatoren der Form id, name, CSS oder XPath erstellt werden. Der generierte Code ist in Python.
	
\end{itemize}

Der Technologiestack von it@M sieht eine Entwicklung der Selenium-Testfälle in Java vor. Als Betriebssystem kommt darüber hinaus Linux zum Einsatz.
Zwei der genannten Lösungsansetzen scheiden daher von vornherein für den produktiven Einsatz beim externen IT-Dienstleister der Landeshauptstadt München aus. Beim SWD Page Recorder handelt es sich um eine .NET Anwendung die nur schwer unter Linux betrieben werden kann. Die WTF PageObject Utility Chrome Extension kann nur im Python-Umfeld betrieben werden. OHMAP wäre aus technischer Sicht eine mögliche Lösungsalternative. Allerdings sind Komfort und Umfang der Anwendung aus sicht von it@M nicht ausreichend. Ohne eigne Konfiguration ist es mit OHMAP nur möglich input-Felder zu extrahieren.
Der HTML-Quelltext muss händisch aus der zu testenden Anwendung extrahiert werden. \\
OWAP als auch der SWD Page Recorder haben zusätzlich das Problem, dass die erzeugten XPath ausdrücke oft sehr einfach gewählt werden und damit sehr stark von der Position der Element innerhalb der Seite abhängig sind. Die eigentlichen Charakteristika der Elemente werden somit oft nicht beachtet. Listing \ref{lst:badXPath}
zeigt einen solche von OHMAP generierten XPath.

\begin{lstlisting}[caption={Einfacher XPath-Locator des Projektes OHMAP},label={lst:badXPath}]
	public class YourPageObjectName {
		//...		
 		@FindBy(xpath = "/html/body/div/div[1]/div[1]/h1/a[2]")
		public WebElement followVirtuetechGmbH;	
		//...
	}
\end{lstlisting}

Der zu adressierende Link in  Listing \ref{lst:badXPath} wird alleine über seine Position innerhalb des DOM der Seite bestimmt.
Um den Locator zu zerstören würde es genügen ein weiteres div-Tag vor dem Link einzufügen.
\\
Ein weiteres Problem, dass sich die gezeigten Lösungen teilen ist, dass sie immer nur ein Page Object auf einmal betrachten. Transitionen, also Übergänge zwischen den einzelnen Webseiten der zu testenden Anwendung, werden somit nicht beachtet. Die dynamische Komponente der Anwendung wird beim generieren der Page Objects somit außer acht gelassen und muss nachträglich händisch hinzugefügt werden.

Mit SeleniPo soll der Versuch unternommen werden die Schwachstellen der bereits existierenden Lösungsansätzen zu verbessern und eine Plattformunabhängige Lösung zu schaffen, die in der IT-Infrastruktur von it@M betrieben werden kann.

\newpage
\section{SeleniPo - Page Object Generator}
\label{sec:selenipo_pogenerator}

Abbildung \ref{fig:poGenerator} zeigt die Denktopanwendung (Page Object Generator) die im Rahmen des Projektes SeleniPo entwickelt wurde. Mit Hilfe dieser Anwendung ist es möglich Page Objects teilautomatisiert zu generieren. Die Anwendung bietet dazu die Möglichkeit einen Browser zu starten und über vorgefertigte Selektoren die Webanwendung nach benötigten Elementen bzw. Transitionen zu durchsuchen. Auf diese Weise kann ein Modell der Anwendung erstellt werden, dass zur Generierung der Page Objects verwendet wird.

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.5]{img/poGenerator.JPG}\\
  \caption{SeleniPo - Page Object Generator}
  \label{fig:poGenerator}
\end{figure}



Das Interface des Page Object Generators teilt sich in drei Bereiche:

\begin{itemize}
	\item Das aktuelle Page Object Modell (Abbildung \ref{fig:poGeneratorPo})
	\item Den HTML-Parser (Abbildung \ref{fig:poGeneratorHtml})
	\item Das Menü (Abbildung \ref{fig:poGeneratorMenu})
\end{itemize}


Abbildung \ref{fig:poGeneratorPo} zeigt den Bereich des Generators mit dem das aktuelle Page Object Modell der zu testenden Anwendung verwaltet werden kann. Mit diesem Bereich der Anwendung können neue Page Objects angelegt und bearbeitet werden. Elemente und Transitionen können manuell hinzugefügt, editiert oder gelöscht werden. Darüber hinaus bietet Die Anwendung die Möglichkeit existierende Elemente und Transitionen auf ihre Richtigkeit zu testen.

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.5]{img/poGeneratorPo.JPG}\\
  \caption{SeleniPo - Page Object Generator - Page Object Model}
  \label{fig:poGeneratorPo}
\end{figure}

\newpage

Abbildung \ref{fig:poGeneratorHtml} zeigt den Bereich des Generators mit dem der Entwickler bei der Erstellung von Elementen und Transitionen im Page Object unterstützt werden kann.
Über den Button Start kann ein Browser gestartet werden. Über das Locator-Dropdown kann dann über vorgefertigte Selektoren die aktuell im Browser dargestellte Webseite nach Elementen bzw. Transitionen durchsucht werden. Im Page Object benötigte Elemente und Transitionen können dann in das ausgewählte Page Object im Page Object Modell übernommen werden.

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.5]{img/poGeneratorHtml.JPG}\\
  \caption{SeleniPo - Page Object Generator - Html Parser}
  \label{fig:poGeneratorHtml}
\end{figure}

\newpage

Abbildung \ref{fig:poGeneratorMenu} markiert das Menü des Page Object Generator. Mit Hilfe des Menüs können Zwischenstände des Page Object Modells gespeichert und geladen werden.
Über das Menü kann darüber hinaus die Generierung der Page Objects aus dem aktuell geladenen Modell gestartet werden.

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.5]{img/poGeneratorMenu.JPG}\\
  \caption{SeleniPo - Page Object Generator - Menü}
  \label{fig:poGeneratorMenu}
\end{figure}

\subsection{Deploymentsicht}

\label{sec:deploymentsicht}
\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.32]{img/Deployment.jpg}\\
  \caption{Einordnung des Page Object Generator in die Deploymentsicht}
  \label{fig:deployment}
\end{figure}

Abbildung \ref{fig:deployment} zeigt die Einordnung des Page Object Generator in die Infrastruktur von it@M. Anhand dieser Abbildung soll gezeigt werden in welchem Bezug sich der Generator zu einer zu testenden Webanwendung und dem späteren Testprojekt befindet.
Zwei übergeordnete Teilbereiche werden unterschieden. Die virtualisierte Serverumgebung (MIA) und der lokale Rechner eines Entwicklers. Auf der virtualisierten Serververumgebung werden die entwicklerübergreifenden Infrastrukturkomponenten wie beispielsweise eine Versionsverwaltung bereitgestellt. Unter dem Entwicklungsrechner ist der Arbeitsplatz eines einzelnen Projektteilnehmers zu verstehen.\\
Auf dem Entwicklungsrechner wird die zu testende Webanwendung entwickelt. Zu Testzwecken kann diese Anwendung in ihrem aktuellen Entwicklungsstand auf einem lokalen Webserver deployt werden.
Der lokale Rechner des Entwicklers ist auch der Ort an dem der Page Object Generator eingesetzt wird. Die lokal deployte Webanwendung kann verwendet werden um für die verschiedenen Seiten der zu testenden Anwendung Page Objects mit Hilfe des Generators zu erzeugen. Diese Page Objects werden bei der Generierung in ein zweites Projekt abgelegt, in welchem die Seleniumtestfälle entwickelt werden. Dieses Projekt wird in Abbildung \ref{fig:deployment} als SeleniPoTestharness bezeichnet und kann vom Entwicklerteam entweder selbst erstellt oder als leeres Quickstart-Projekt vorgefertigt bezogen werden. Mit Hilfe der Page Objects im Testharness können Testfälle entwickelt werden die während der Erstellung auf dem lokalen Entwicklungsrechner gegen die lokal deployte Webanwendung ausgeführt werden.
Der Sourcecode der zu testende Webanwendung als auch des SeleniPoTestharness wir in einer Versionsverwaltung in der virtualisierten Severumgebung abgelegt. Bei it@M wird zu diesem Zweck Subversion eingesetzt. Über die Versionsverwaltung kann eine Softwareproduktionsstraße bedient werden die das bauen, deployen und testen der der Webanwendung automatisiert. Bei it@M kommt hierfür der Continuous Integration Server Jenkins zum Einsatz. Jenkins bezieht die jeweils aktuellen Sourcen für das Testprojekt und die Webanwendung aus dem Subversion und kann so regelmäßig eine aktuelle Version der Webanwendung bauen und auf ein Testsystem in der virtuellen Serverumgebung deployen. Der aktuelle Testharness kann dann analog von Jenkins gesteuert die aktuell entwickelten Selenium Testfälle gegen diesen Webserver zur Ausführung bringen.



\subsection{Möglicher Ablauf eines Standartanwendungsfall}
\label{sec:moeglicher_ablauf_eines_standartanwendungsfall}

Abbildung \ref{fig:sequenz} zeigt auf hoher Abstraktionsebene einen Standartablauf bei der Benutzung des Page Object Generators.



\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.5]{img/Sequenzdiagramm.jpg}\\
  \caption{Möglicher Ablauf eines Standartanwendungsfall}
  \label{fig:sequenz}
\end{figure}

Über das Menü (siehe Abbildung \ref{fig:poGeneratorMenu}) hat der Benutzer des Page Object Generator die Möglichkeit einen bereits zuvor angelegten Zwischenstand des Page Object Modells aus einer XML-Datei zu laden. Die Bereits angelegten Page Objects werden nach dem Laden im Dropdown im bereich des Page Object Modells (siehe Abbildung \ref{fig:poGeneratorPo}) angezeigt. Der Benutzer hat nun die Möglichkeit mit den bereit vorhandenen Page Objects weiterzuarbeiten oder ein neues Page Object anzulegen. Entscheidet er sich dazu, ein neues Page Object anzulegen, wird dieses vorausgewählt im Modell angezeigt. Das Page Object kann nun manuell mit Elemente bzw. Transitionen befüllt werden. Um das Page Object teilautomatisiert zu befüllen kann über den Start-Button ein Webbrowser gestartet werden. Im Browser muss die Seite der Webanwendung geladen werden die dem aktuell ausgewählten Page Object entspricht. Mit dem Dropdown des HTML-Parser (siehe Abbildung \ref{fig:poGeneratorHtml}) kann nun die ausgewählte Webseite nach passenden Elementen bzw. Transitionen durchsucht werden.
Passende Ergebnisse können in das ausgewählte Page Object übernommen und dort bei Bedarf noch einmal überarbeitet werden.
Der neu erreichte Zwischenstand kann wiederum über das Menü gespeichert werden.
Um die Page Objects als Code aus dem Modell zu erzeugen kann über das Menü die Generierung gestartet werden. Bei richtiger Konfiguration des Page Object Generators muss dazu lediglich das Rootverzeichnis des entsprechenden Testprojektes als Zielort der Generierung ausgewählt werden.


\subsection{Anwendungsfälle des Page Object Generator}
\label{sec:page_object_generator_usecases}

Die Anwendungsfälle des Page Object Generators sind in Abbildung \ref{fig:use_case} dargestellt und werden im nachfolgenden Abschnitt näher beschrieben. 

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.45]{img/Use-Cases.jpg}\\
  \caption{Anwendungsfälle des Page Object Generator}
  \label{fig:use_case}
\end{figure}

\subsubsection{Neues Page Object anlegen}
\label{sec:neues_page_object_anlegen}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler legt ein neues Page Object an. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler benötigt Page Object in den Testfällen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: &  \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Name und Packege des Page Object \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Page Object ist ausgewählt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Page Object wurde im Modell der Anwendung angelegt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler startet den Vorgang zum anlegen eines neuen Page Object. 
\item[2.] System zeigt Dialog an. 
\item[3.] Entwickler trägt Namen des Page Object im Dialogs ein.
\item[4.] Entwickler bestätigt den Dialog.
\item[5.] System prüft eingaben.
\item[6.] System wählt Page Object aus.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 4-6:
\begin{itemize}[itemsep=0pt]
\item[4.] Entwickler bricht Vorgang ab. 
\item[5.] System ändert internen Zustand nicht. 
\end{itemize}

\paragraph{Validierung fehlgeschlagen}
Statt Schritt 6:
\begin{itemize}[itemsep=0pt]
\item[6.] System zeigt Fehlermeldung an. 
\item[7.] Entwickler bestätigt Fehlermeldung. 
\end{itemize}
Weiter mit Punkt 3. 

\paragraph{Paketstruktur des Page Object verfeinern}
Statt Schritt 4:
\begin{itemize}[itemsep=0pt]
\item[4.] Entwickler trägt Package des Page Object ein.
\end{itemize}
Weiter mit Punkt 4. 
 

\subsubsection{Neues Element hinzufügen}
\label{sec:neues_element_hinzufügen}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler legt ein Element in einem Page Object an. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler benötigt Element der Seite in den Testfällen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Page Object bereits angelegt.\\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Interner Name des Element, Art des Selectors, Locator der das Element in der Seite identifiziert \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Element wird in den Elementen des Page Object angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Element wurde im Modell der Anwendung angelegt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt Page Object aus.
\item[2.] Entwickler wählt Bereich für die Elemente des Page Objects aus. 
\item[3.] System wechselt in den internen Zustand zum bearbeiten von Elementen.
\item[4.] Entwickler startet den Vorgang zum anlegen eines neuen Eintrags.
\item[5.] System zeigt Dialog an. 
\item[6.] Entwickler befüllt Dialog.
\item[7.] Entwickler bestätigt den Dialog.
\item[8.] System prüft ob alle Felder befüllt sind.
\item[9.] System zeigt Element in den Elementen des Page Object an.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 7-9:
\begin{itemize}[itemsep=0pt]
\item[7.] Entwickler bricht Vorgang ab. 
\item[8.] System ändert internen Zustand nicht. 
\end{itemize}

\paragraph{Validierung fehlgeschlagen}
Statt Schritt 9:
\begin{itemize}
\item[9.] System zeigt Fehlermeldung an. 
\item[10.] Entwickler bestätigt Fehlermeldung. 
\end{itemize}
Weiter mit Punkt 6. 


\subsubsection{Neue Transition hinzufügen}
\label{sec:neue_transition_hinzufügen}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler legt einen Seitenübergang zu einem anderen Page Object an. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler benötigt einen Übergang zu einer anderen Seite in den Testfällen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Page Object bereits angelegt. Page Object das Ziel des Seitenübergangs ist wurde bereits angelget.\\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Interner Name des Element, Art des Selectors, Locator der das Element in der Seite identifiziert, Ziel Page Object \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Transition wird in den Transitions des Page Object angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Transition wurde im Modell der Anwendung angelegt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt Page Object aus.
\item[2.] Entwickler wählt Bereich für die Transitions des Page Objects aus. 
\item[3.] System wechselt in den internen Zustand zum bearbeiten von Transitions.
\item[4.] Entwickler startet den Vorgang zum anlegen eines neuen Eintrags.
\item[5.] System zeigt Dialog an. 
\item[6.] Entwickler befüllt Dialog.
\item[7.] Entwickler bestätigt den Dialog.
\item[8.] System prüft ob alle Felder befüllt sind.
\item[9.] System zeigt Transition in den Transitions des Page Object an.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 7-9:
\begin{itemize}[itemsep=0pt]
\item[7.] Entwickler bricht Vorgang ab. 
\item[8.] System ändert internen Zustand nicht. 
\end{itemize}

\paragraph{Validierung fehlgeschlagen}
Statt Schritt 9:
\begin{itemize}
\item[9.] System zeigt Fehlermeldung an. 
\item[10.] Entwickler bestätigt Fehlermeldung. 
\end{itemize}
Weiter mit Punkt 6. 


\subsubsection{Element aus HTML übernehmen}
\label{sec:element_from_html}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler legt teilautomatisiert ein neues Element im Page Object an. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler benötigt Element der Seite in den Testfällen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Page Object bereits angelegt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Seitenquelltext der ausgewählten Webseite. Art des Locators. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Element wird in den Elementen des Page Object angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Element wurde im Modell der Anwendung angelegt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt passendes Page Object aus.
\item[2.] Entwickler startet aus der Anwendung heraus den Webbrowser mit der zum ausgewählten Page Object korrespondierenden Seite. 
\item[3.] Entwickler wählt Art des Locators aus für den die Seite durchsucht werden soll.
\item[4.] Entwickler wählt Aktion zum Analysieren der ausgewählten Webseite aus.
\item[5.] System zeigt die für den ausgewählten Locator auf der Seite identifizierten Elemente an.
\item[6.] Entwickler wählt gewünschtes Element aus den Treffern aus. 
\item[7.] Entwickler wählt Aktion zum übernehmen des Elements in das Page Object aus.
\item[8.] System zeigt Element in den Elementen des Page Object an.
\end{itemize}

\paragraph{Testen des Elements}
Statt Schritt 7-8:
\begin{itemize}
\item[7.] Entwickler wählt Aktion zum Testen des ausgewählten Elements aus. 
\item[8.] System zeigt an ob das Element auf der ausgewählten Webseite erfolgreich erreicht werden konnte. 
\end{itemize}
Weiter mit Punkt 7. 

\subsubsection{Transition aus HTML übernehmen}
\label{sec:Transition_from_html}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler legt teilautomatisiert einen neuen Seitenübergang an. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler benötigt einen Übergang zu einer anderen Seite in den Testfällen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Page Object bereits angelegt. Page Object das Ziel des Seitenübergangs ist wurde bereits angelget. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Art des Locators. Ziel Page Object \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Transition wird in den Transitions des Page Object angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Transition wurde im Modell der Anwendung angelegt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt passendes Page Object aus.
\item[2.] Entwickler startet aus der Anwendung heraus den Webbrowser mit der zum ausgewählten Page Object korrespondierenden Seite. 
\item[3.] Entwickler wählt Art des Locators aus für den die Seite durchsucht werden soll.
\item[4.] Entwickler wählt Aktion zum Analysieren der ausgewählten Webseite aus.
\item[5.] System zeigt die für den ausgewählten Locator auf der Seite identifizierten Elemente an.
\item[6.] Entwickler wählt gewünschtes Element aus den Treffern aus. 
\item[7.] Entwickler wählt Aktion zum übernehmen des Elements als Transition in das Page Object aus.
\item[8.] System zeigt Dialog mit den Informationen der ausgewählten Elements an.
\item[9.] Entwickler ergänzt die Informationen um das Ziel Page Object der Transition.
\item[10.] Entwickler bestätigt den Dialog.
\item[11.] System prüft ob alle Felder befüllt sind.
\item[12.] System zeigt Element in den Transitions des Page Object an.
\end{itemize}

\paragraph{Testen der Transition}
Statt Schritt 7-8:
\begin{itemize}
\item[7.] Entwickler wählt Aktion zum Testen des ausgewählten Elements aus. 
\item[8.] System zeigt an ob das Element auf der ausgewählten Webseite erfolgreich erreicht werden konnte. 
\end{itemize}
Weiter mit Punkt 7.

\paragraph{Vorgang abgebrochen}
Statt Schritt 10-12:
\begin{itemize}[itemsep=0pt]
\item[10.] Entwickler bricht Vorgang ab. 
\item[11.] System ändert internen Zustand nicht. 
\end{itemize}

\paragraph{Validierung fehlgeschlagen}
Statt Schritt 12:
\begin{itemize}
\item[12.] System zeigt Fehlermeldung an. 
\item[13.] Entwickler bestätigt Fehlermeldung. 
\end{itemize}
Weiter mit Punkt 6. 


\subsubsection{Vorhandenen Eintrag editieren}
\label{sec:edit_entry}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler editiert bereits vorhandenen Eintrag. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte einen bereits vorhandenen Eintrag überarbeiten. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Eintrag bereits vorhanden. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Geänderte Werte. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Eintrag wird in aktualisierte Form angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Eintrag wurde im Modell der Anwendung aktualisiert.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt den zu editierenden Eintrag aus.
\item[2.] Entwickler löst die Aktion zum Editieren der aktuellen Auswahl aus. 
\item[3.] System zeigt Dialog mit den alten Werten des Eintrags an.
\item[4.] Entwickler nimmt die gewünschten Änderungen vor.
\item[5.] Entwickler bestätigt den Dialog
\item[8.] System prüft die Felder des Dialogs.
\item[7.] System zeigt den Eintrag in aktualisierter Form an.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 5-7:
\begin{itemize}[itemsep=0pt]
\item[5.] Entwickler bricht Vorgang ab. 
\item[6.] System ändert internen Zustand nicht. 
\end{itemize}

\paragraph{Validierung fehlgeschlagen}
Statt Schritt 7:
\begin{itemize}[itemsep=0pt]
\item[6.] System zeigt Fehlermeldung an. 
\item[7.] Entwickler bestätigt Fehlermeldung. 
\end{itemize}
Weiter mit Punkt 4. 

\subsubsection{Vorhandenen Eintrag löschen}
\label{sec:delete_entry}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler löscht bereits vorhandenen Eintrag. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte einen bereits vorhandenen Eintrag löschen. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Eintrag bereits vorhanden. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Eintrag wird nicht mehr angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Eintrag wurde aus dem Modell der Anwendung entfernt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt den zu löschenden Eintrag aus.
\item[2.] Entwickler löst die Aktion zum Löschen der aktuellen Auswahl aus. 
\item[3.] System entfernt den ausgewählten Eintrag.
\end{itemize}

\paragraph{Löschen eines gesamten Page Object}
Statt Schritt 3:
\begin{itemize}[itemsep=0pt]
\item[3.] System zeigt einen Bestätigungsdialog an. 
\item[4.] Entwickler bestätigt Dialog. 
\end{itemize}
Weiter mit Punkt 3. 

\paragraph{Vorgang abgebrochen}
Statt Schritt 4 des Sonderfalls Löschen eines gesamten Page Object:
\begin{itemize}[itemsep=0pt]
\item[4.] Entwickler bricht Vorgang ab. 
\item[5.] System ändert internen Zustand nicht. 
\end{itemize}

\subsubsection{Vorhandenen Eintrag testen}
\label{sec:test_entry}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler testest einen vorhanden Eintrag. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte die Erreichbarkeit eines bereits vorhandenen Eintrags prüfe. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Eintrag bereits vorhanden. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Eintrag ist mit dem Testergebnis markiert. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Modell der Anwendung ist unverändert.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler startet aus der Anwendung heraus den Webbrowser mit der Seite auf der sich der zu testende Eintrag befindet. 
\item[2.] Entwickler wählt den zu testenden Eintrag aus.
\item[3.] Entwickler löst die Aktion zum Testen der aktuellen Auswahl aus. 
\item[4.] System zeigt Ergebnis des Tests an.
\end{itemize}


\subsubsection{Laden eines vorhandenen Modells}
\label{sec:load}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler lädt ein zuvor angelegt und gespeichertes Modell. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte einen alten Speicherstand laden. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: & 
Save Datei vorhanden. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & Save Datei\\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Einträge der Save Datei werden angezeigt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Modell der Anwendung wurde mit den Werden aus der Save Datei befüllt.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt die Aktion zum Laden einer Save Datei aus.
\item[2.] System öffnet Auswahldialog. 
\item[3.] Entwickler wählt Save Datei aus.
\item[4.] System zeigt die Einträge der Save Datei an.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 3:
\begin{itemize}[itemsep=0pt]
\item[3.] Entwickler bricht Vorgang ab. 
\item[4.] System ändert internen Zustand nicht. 
\end{itemize}

\subsubsection{Speichern eines vorhandenen Modells}
\label{sec:save}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler speichert einen Stand der Anwendung. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte einen Stand der Anwendung zur späteren Wiederherstellbarkeit speichern. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: &  \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Save Datei wurde angelegt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Save Datei im Zielpfad vorhanden.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt die Aktion zum Speichern eines Zwischenstands aus.
\item[2.] System öffnet Auswahldialog. 
\item[3.] Entwickler wählt Ort zum Ablegen der Save Datei aus.
\item[4.] System erzeugt Save Datei.
\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 3:
\begin{itemize}[itemsep=0pt]
\item[3.] Entwickler bricht Vorgang ab. 
\item[4.] System ändert internen Zustand nicht. 
\end{itemize}

\subsubsection{Page Objects generieren}
\label{sec:generate_page_objects}

\begin{tabular}[h]{|p{4cm}|p{11,5cm}|}
\hline 
\rule[-1ex]{0pt}{2.5ex}Kurzbeschreibung: & 
Entwickler erzeugt Quellcode aus dem in der Anwendung erzeugten Modell. \\  
\hline 
\rule[-1ex]{0pt}{2.5ex}Akteure: & 
Entwickler \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Motivation: & 
Entwickler möchte aus einem Stand der Anwendung Page Object Klassen generieren. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Vorbedingung: &  \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Eingehende Daten: & \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Ergebnisse: & Page Object Klassen wurden erzeugt. \\ 
\hline 
\rule[-1ex]{0pt}{2.5ex}Nachbedingungen: & Page Objects im Zielpfad vorhanden.  \\ 
\hline 
\end{tabular} 

\paragraph{Ablauf}

\begin{itemize}[itemsep=0pt]
\item[1.] Entwickler wählt die Aktion zum Generieren der Page Objects aus.
\item[2.] System öffnet Auswahldialog. 
\item[3.] Entwickler wählt Ort von dem ausgehend die Page Objects abgelegt werden sollen.
\item[4.] System generiert aus den Informationen des Aktuellen Modells der Anwendung die entsprechenden Page Object Klassen.

\end{itemize}

\paragraph{Vorgang abgebrochen}
Statt Schritt 3:
\begin{itemize}[itemsep=0pt]
\item[3.] Entwickler bricht Vorgang ab. 
\item[4.] System ändert internen Zustand nicht. 
\end{itemize}


\newpage
TODO: 

--> die einzelnen Usecases fachlich beschreiben.

Technische Sicht. 
Komponentendiagramm Allgemein erklären.

Jede Komponente abarbeiten in sinnvoller tiefe (z.B. Klassendiagram / Zustandsautomat ect.)









\section{Aufbau des Systems}

\subsection{pro modul ein kapitel}

\section{Ausblick}

